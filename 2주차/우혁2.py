# https://leetcode.com/problems/perfect-squares/
class Solution:
    '''
        n을 제곱 수 m개의 합으로 표현했을 때, 가장 작은 m을 구하는 문제.
    '''
    def numSquares(self, n: int) -> int:
        # 풀이
        # 여러 숫자를 대입하며, 제곱수의 규칙성을 찾는다.
        # n이 1일 때, 제곱수 1로 표현이 가능하므로 m은 1
        # n이 2일 때, 제곱수 1, 1로 표현이 가능하므로 m은 2
        # n이 3일 때, 제곱수 1, 1, 1로 표현이 가능하므로 m은 3
        # n이 4일 때, 제곱수 4로 표현이 가능하므로 m은 1
        # n이 5일 때, 제곱수 4, 1로 표현이 가능하므로 m은 2
        # n이 6일 때, 제곱수 4, 1, 1로 표현이 가능하므로 m은 3
        # n이 7일 때, 제곱수 4, 1, 1, 1로 표현이 가능하므로 m은 4
        # n이 8일 때, 제곱수 4, 4로 표현이 가능하므로 m은 2
        # n이 9일 때, 제곱수 9로 표현이 가능하므로 m은 1
        # n이 10일 때, 제곱수 9, 1로 표현이 가능하므로 m은 4
        # 1) 1 ~ 3, 5 ~ 7과 10일 때, f(n) = f(n - 1) + 1이 성립한다.
        # 2) 1, 4, 9는 제곱수이므로 1이 된다.
        # 8은 1), 2) 모두 성립하지 않는다.
        # 8은 제곱수인 4, 4로 표현이 가능하다.
        # 3) 8은 제곱수의 배수이므로 몫인 2가 된다.
        # 1), 2), 3)에서 찾은 규칙이 성립하는지 조금 더 알아보자.
        # n = 11, 제곱수 9, 1, 1, m = 3
        # n = 12, 제곱수 4, 4, 4, m = 4
        # n = 13, 제곱수 9, 4, m = 2
        # n = 14, 제곱수 9, 4, 1, m = 3
        # n = 15, 제곱수 9, 4, 1, 1, m = 4
        # n = 16, 제곱수 16, m = 1
        # n = 17, 제곱수 16, 1, m = 2
        # n = 18, 제곱수 9, 9, m = 2
        # n = 19, 제곱수 9, 9, 1, m = 4
        # n = 20, 제곱수 16, 4, m = 2
        # n = 21, 제곱수 16, 4, 1, m = 3
        # n = 22, 제곱수 9, 9, 4, m = 3
        # n = 23, 제곱수 9, 9, 4, 1, m = 4
        # n = 24, 제곱수 16, 4, 4, m = 3
        # n = 25, 제곱수 25, m = 1
        # n = 26, 제곱수 25, 1, m = 2
        # n = 27, 제곱수 25, 1, 1, m = 3
        # n = 28, 제곱수 25, 1, 1, 1, m = 4
        # 11, 12, 14, 15, 17, 19, 21, 23, 26, 27, 28은 f(n) = f(n - 1) + 1이 성립한다.
        # 16, 25는 제곱수이므로 1이 된다.
        # 18은 제곱수 9의 배수이므로 몫인 2가 된다.
        # 4) 13, 20, 22는 이전 값에서 더 낮은 제곱수의 집합인 값이 큰 제곱수로 변환되며 감소하게 된다.
        # 12 -> 4, 4, 4
        # 13 -> 4, 4, 4, 1 -> 9, 4
        # 19 -> 9, 9, 1
        # 20 -> 9, 9, 1, 1 -> 16, 4
        # 21 -> 16, 4, 1
        # 22 -> 16, 4, 1, 1 -> 9, 9, 4
        # 13은 9나 4에서 4나 9를 더 한 값이며,
        # 20은 16이나 4에서 4나 16을 더 한 값이다.
        # 22는 13이나 18에서 9나 4를 더 한 값이다.
        # 4의 배수인 8, 12는 각각 m = 2, m = 3이라는 결과가 나온다.
        # 이를 통해 같은 제곱수의 배수에서도 동일함을 알 수 있다.
        # 결국 f(n) = f(n - 1) + 1과 f(n) = f(n - 제곱수) + 1을 비교해야한다.
        # 이 때, 예시는 작은 수 이기에 아무 제곱수를 제외해도 동일하지만
        # 제곱수 16 대신 제곱수 4를 사용하게되면 최적해를 도출할 수 없게 된다.
        # 그러므로 f(n - 1) + 1과 f(n - 제곱수) + 1의 대소관계를 비교할 때,
        # 구해진 모든 제곱수를 순회하며, 가장 작은 값을 확인해야 한다.

        # n 이하의 제곱수의 배열을 생성한다.
        nums = [i ** 2 for i in range(1, int(n ** 0.5) + 1)]
        # n 까지의 결과를 담을 배열을 생성한다.
        squares = [1] * (n + 1)
        squares[0] = 0
        for i in range(1, n + 1):
            # i가 제곱수에 해당할 경우 최초로 할당해둔 1이 정답이므로 처리하지 않는다.
            if i not in nums:
                # 일반적으로 f(n)은 f(n - 1) + 1이 된다.
                squares[i] = squares[i - 1] + 1
                for num in nums:
                    if num > i:
                        break
                    # f(n - 1) + 1과 f(n - 제곱수) + 1중 작은 값으로 최소 값을 갱신한다.
                    squares[i] = min(squares[i], squares[i - num] + 1)
        return squares[-1]