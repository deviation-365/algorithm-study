'''
    dp문제로 점화식을 세울 때 문제의 제약조건을 주의한다.
'''

n = int(input())
arr = [0] + [int(input()) for i in range(n)]
# dp에는 n번째 잔까지 마실 수 있는 포도주의 최댓값을 저장한다.
dp = [0] * (n + 1)
dp[1] = arr[1]
# n이 1인 경우 조건문이 없으면 index error가 발생.
if n > 1:
    dp[2] = arr[1] + arr[2]
for i in range(3, n + 1):
    # i번째에 해당하는 최댓값은 두가지로 생각할 수 있다.
    # dp[i - 1]이 최댓값인 경우
    # dp[i - 2]가 최댓값인 경우
    # 하지만 dp[i - 1]이 최댓값이어도 선택이 불가능할 수 있다.
    # 예를 들어 주어진 포도주 배열이 [1, 6, 5, 5]인 경우
    # dp 3까지의 값은 아래와 같다.
    # [1, 7, 11]
    # dp[4]는 dp[3] + arr[4]의 16이 아닌 dp[2] + arr[4]인 12가 된다.
    # dp[3]은 arr[2]와 arr[3]의 합이므로 제약조건에 해당하기 때문이다.
    # 그러므로 최댓값을 찾을 때,
    # dp[i - 1]이 아닌 dp[i - 3]이 필요하며,
    # dp[i - 3]을 선택한 상태에서는 arr[i - 1]이 가능하므로 점화식은 아래와 같다.
    # dp[i] = max(dp[i - 2], dp[i - 3] + arr[i - 1]) + arr[i]
    # 여기서 문제의 조건 중 중요한 사항을 고려해야한다.
    # 오르막 길 문제와는 다르게 마지막 잔을 꼭 선택할 필요가 없다.
    # 예를 들어 주어진 포도주 배열이 [20, 100, 200, 5]인 경우
    # dp = [20, 120, 300, 125]가 된다.
    # 그러므로 최댓값이 dp[n]이 아닌 dp[n - 1]이 될 수도 있음을 유의한다.
    # 최종적인 점화식은 아래와 같다.
    dp[i] = max(arr[i] + dp[i - 2], arr[i] + dp[i - 3] + arr[i - 1], dp[i - 1])
print(dp[n])